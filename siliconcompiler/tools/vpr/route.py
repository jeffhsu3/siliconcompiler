import shutil

from siliconcompiler import utils
from siliconcompiler.tools.vpr import vpr
from siliconcompiler.tools.vpr.vpr import VPRTask
from siliconcompiler.tools._common import get_tool_task


class RouteTask(VPRTask):
    def __init__(self):
        super().__init__()

        self.add_parameter("max_router_iterations", "int",
                           "set maximum number of routing iterations", defvalue=50)
        self.add_parameter("gen_post_implementation_netlist", "bool",
                           "set to true to have VPR generate a post-implementation netlist",
                           defvalue=False)
        self.add_parameter("timing_corner", "str",
                           "set the timing corner for files generated by the post-implementation "
                           "netlist", defvalue="typical")

    def task(self):
        return "route"

    def setup(self):
        super().setup()

        self.add_input_file(ext="blif")
        self.add_input_file(ext="net")
        self.add_input_file(ext="place")

        self.add_output_file(ext="route")
        self.add_output_file(ext="blif")
        self.add_output_file(ext="net")
        self.add_output_file(ext="place")

        # Timing
        self.add_output_file(ext="vg")
        self.add_output_file(ext="sdc")
        self.add_output_file(ext=f"{self.get('var', 'timing_corner')}.sdf")

    def runtime_options(self):
        options = super().runtime_options()

        options.append(f"inputs/{self.design_topmodule}.blif")

        options.append("--route")

        # To run only the routing step we need to pass in the placement files
        options.extend(['--net_file', f'inputs/{self.design_topmodule}.net'])
        options.extend(['--place_file', f'inputs/{self.design_topmodule}.place'])

        options.extend(['--max_router_iterations', self.get("var", "max_router_iterations")])

        if self.get("var", "enable_images"):
            graphics_commands = self._get_common_graphics()

            # set_draw_block_text 0 hides the label for various blocks in the design
            # set_draw_block_outlines 0 removes the outline/boundary for various blocks in the
            # design
            # set_routing_util 1 displays the routing utilization as a heat map
            # set_routing_util 4 displays the routing utilization as a heat map over placed blocks
            # Refer: https://github.com/verilog-to-routing/vtr-verilog-to-routing/blob/master/
            # vpr/src/draw/draw_types.h#L89
            # save_graphics saves the block diagram as a png/svg/pdf
            # Refer:
            # https://docs.verilogtorouting.org/en/latest/vpr/command_line_usage/#graphics-options
            graphics_commands.append(
                "set_draw_block_text 0; " +
                "set_draw_block_outlines 0; " +
                "set_routing_util 1; " +
                "save_graphics "
                f"reports/{self.design_topmodule}_route_utilization_with_placement.png;")
            graphics_commands.append(
                "set_draw_block_text 0; " +
                "set_draw_block_outlines 0; " +
                "set_routing_util 4; " +
                "save_graphics "
                f"reports/{self.design_topmodule}_route_utilization.png;")

            options.extend(["--graphics_commands", " ".join(graphics_commands)])

        # Generate a post-implementation netlist for use in external timing analysis
        # if requested.
        if self.get("var", "gen_post_implementation_netlist"):
            # Generate the netlist.
            options.extend(["--gen_post_synthesis_netlist", "on"])
            # Generate the SDC file.
            options.extend(["--gen_post_implementation_sdc", "on"])
            # Create undriven nets for unconnected inputs.
            options.extend(["--post_synth_netlist_unconn_inputs", "nets"])
            # Turn off module parameters.
            options.extend(["--post_synth_netlist_module_parameters", "off"])

        return options

    def post_process(self):
        super().post_process()

        shutil.copy2(f'inputs/{self.design_topmodule}.blif', 'outputs')
        shutil.copy2(f'inputs/{self.design_topmodule}.net', 'outputs')
        shutil.copy2(f'inputs/{self.design_topmodule}.place', 'outputs')

        if self.get("var", "gen_post_implementation_netlist"):
            # These files will only exist if timing analysis is on and VPR was told
            # to generate them.
            shutil.move(f'{self.design_topmodule}_post_synthesis.v',
                        f'outputs/{self.design_topmodule}.vg')
            shutil.move(f'{self.design_topmodule}_post_synthesis.sdc',
                        f'outputs/{self.design_topmodule}.sdc')
            shutil.move(f'{self.design_topmodule}_post_synthesis.sdf',
                        f'outputs/{self.design_topmodule}.{self.get("var", "timing_corner")}.sdf')
        else:
            # If timing analysis is on or we are not generating a post-implementation
            # netlist, just produce blank files. These will trigger any future nodes
            # that use them to skip.
            open(f'outputs/{self.design_topmodule}.vg', 'w')
            open(f'outputs/{self.design_topmodule}.sdc', 'w')
            open(f'outputs/{self.design_topmodule}.{self.get("var", "timing_corner")}.sdf', 'w')


def setup(chip, clobber=True):
    '''
    Perform automated place and route with VPR
    '''

    tool = 'vpr'
    step = chip.get('arg', 'step')
    index = chip.get('arg', 'index')
    _, task = get_tool_task(chip, step, index)

    vpr.setup_tool(chip, clobber=clobber)

    # Match VPR's default max router iterations value so that
    # the parameter is traceable by SC through the flow.
    chip.set('tool', tool, 'task', task, 'var', 'max_router_iterations', "50",
             step=step, index=index, clobber=False)

    chip.set('tool', tool, 'task', task, 'var', 'max_router_iterations',
             'set maximum number of routing iterations',
             field='help')

    chip.add('tool', tool, 'task', task, 'require',
             ",".join(['tool', tool, 'task', task, 'var', 'max_router_iterations']),
             step=step, index=index)

    chip.set('tool', tool, 'task', task, 'threads', utils.get_cores(),
             step=step, index=index, clobber=clobber)

    # TO-DO: PRIOROTIZE the post-routing packing results?
    design = chip.top()
    chip.set('tool', tool, 'task', task, 'input', design + '.blif', step=step, index=index)
    chip.add('tool', tool, 'task', task, 'input', design + '.net', step=step, index=index)
    chip.add('tool', tool, 'task', task, 'input', design + '.place', step=step, index=index)

    chip.set('tool', tool, 'task', task, 'output', design + '.route', step=step, index=index)
    chip.add('tool', tool, 'task', task, 'output', design + '.blif', step=step, index=index)
    chip.add('tool', tool, 'task', task, 'output', design + '.net', step=step, index=index)
    chip.add('tool', tool, 'task', task, 'output', design + '.place', step=step, index=index)

    # Add a parameter for generating a post-implementation netlist for external
    # static timing analysis.
    if vpr.use_timing_analysis(chip):
        chip.set('tool', tool, 'task', task, 'var', 'gen_post_implementation_netlist',
                 True, step=step, index=index, clobber=False)
    else:
        chip.set('tool', tool, 'task', task, 'var', 'gen_post_implementation_netlist',
                 False, step=step, index=index, clobber=False)

    chip.set('tool', tool, 'task', task, 'var', 'gen_post_implementation_netlist',
             'set to true to have VPR generate a post-implementation netlist',
             field='help')

    chip.set('tool', tool, 'task', task, 'require',
             ",".join(['tool', tool, 'task', task, 'var', 'gen_post_implementation_netlist']),
             step=step, index=index)

    # Add a parameter to control the timing corner used when generating SDF files.
    chip.set('tool', tool, 'task', task, 'var', 'timing_corner', 'typical',
             step=step, index=index, clobber=False)

    chip.set('tool', tool, 'task', task, 'var', 'timing_corner',
             'set the timing corner for files generated by the post-implementation netlist',
             field='help')

    chip.set('tool', tool, 'task', task, 'require',
             ",".join(['tool', tool, 'task', task, 'var', 'timing_corner']),
             step=step, index=index)

    # Add the post-implementation timing netlist outputs for the timing step.
    # These files must always be generated so nodes that are connected after this
    # step that are expecting these files do not complain if they are not generated.
    timing_corner = chip.get('tool', tool, 'task', task, 'var', 'timing_corner',
                             step=step, index=index)[0]

    chip.add('tool', tool, 'task', task, 'output', f'{design}.vg',
             step=step, index=index)
    chip.add('tool', tool, 'task', task, 'output', f'{design}.sdc',
             step=step, index=index)
    chip.add('tool', tool, 'task', task, 'output', f'{design}.{timing_corner}.sdf',
             step=step, index=index)


def runtime_options(chip):
    '''Command line options to vpr for the route step
    '''

    step = chip.get('arg', 'step')
    index = chip.get('arg', 'index')
    tool, task = get_tool_task(chip, step, index)

    design = chip.top()

    options = vpr.runtime_options(chip)

    blif = f"inputs/{design}.blif"
    options.append(blif)

    options.append('--route')
    # To run only the routing step we need to pass in the placement files
    options.extend(['--net_file', f'inputs/{design}.net'])
    options.extend(['--place_file', f'inputs/{design}.place'])

    enable_images = chip.get('tool', tool, 'task', task, 'var', 'enable_images',
                             step=step, index=index)[0]

    route_iterations = chip.get('tool', tool, 'task', task, 'var', 'max_router_iterations',
                                step=step, index=index)

    if (len(route_iterations) > 0):
        options.extend(['--max_router_iterations', route_iterations[0]])

    if enable_images == 'true':
        design = chip.top()

        graphics_commands = vpr.get_common_graphics(chip)

        # set_draw_block_text 0 hides the label for various blocks in the design
        # set_draw_block_outlines 0 removes the outline/boundary for various blocks in the design
        # set_routing_util 1 displays the routing utilization as a heat map
        # set_routing_util 4 displays the routing utilization as a heat map over placed blocks
        # Refer: https://github.com/verilog-to-routing/vtr-verilog-to-routing/blob/master/
        # vpr/src/draw/draw_types.h#L89
        # save_graphics saves the block diagram as a png/svg/pdf
        # Refer:
        # https://docs.verilogtorouting.org/en/latest/vpr/command_line_usage/#graphics-options
        graphics_commands.append("set_draw_block_text 0; " +
                                 "set_draw_block_outlines 0; " +
                                 "set_routing_util 1; " +
                                 "save_graphics "
                                 f"reports/{design}_route_utilization_with_placement.png;")
        graphics_commands.append("set_draw_block_text 0; " +
                                 "set_draw_block_outlines 0; " +
                                 "set_routing_util 4; " +
                                 "save_graphics "
                                 f"reports/{design}_route_utilization.png;")

        graphics_command_str = " ".join(graphics_commands)

        options.append("--graphics_commands")
        options.append(graphics_command_str)

    # Generate a post-implementation netlist for use in external timing analysis
    # if requested.
    gen_post_implementation_netlist = chip.get('tool', tool, 'task', task, 'var',
                                               'gen_post_implementation_netlist',
                                               step=step, index=index)[0]
    if gen_post_implementation_netlist == 'true':
        # Generate the netlist.
        options.extend(["--gen_post_synthesis_netlist", "on"])
        # Generate the SDC file.
        options.extend(["--gen_post_implementation_sdc", "on"])
        # Create undriven nets for unconnected inputs.
        options.extend(["--post_synth_netlist_unconn_inputs", "nets"])
        # Turn off module parameters.
        options.extend(["--post_synth_netlist_module_parameters", "off"])

    return options


################################
# Post_process (post executable)
################################


def post_process(chip):
    ''' Tool specific function to run after step execution
    '''
    vpr.vpr_post_process(chip)

    design = chip.top()
    # Forward all of the prior step inputs forward for bitstream generation
    shutil.copy2(f'inputs/{design}.blif', 'outputs')
    shutil.copy2(f'inputs/{design}.net', 'outputs')
    shutil.copy2(f'inputs/{design}.place', 'outputs')

    # Copy and rename the post-implementation netlist results into the output
    # directory to be used in external timing analysis.
    step = chip.get('arg', 'step')
    index = chip.get('arg', 'index')
    tool, task = get_tool_task(chip, step, index)
    gen_post_implementation_netlist = chip.get('tool', tool, 'task', task, 'var',
                                               'gen_post_implementation_netlist',
                                               step=step, index=index)[0]
    timing_corner = chip.get('tool', tool, 'task', task, 'var', 'timing_corner',
                             step=step, index=index)[0]

    if vpr.use_timing_analysis(chip) and gen_post_implementation_netlist == 'true':
        # These files will only exist if timing analysis is on and VPR was told
        # to generate them.
        shutil.move(f'{design}_post_synthesis.v', f'outputs/{design}.vg')
        shutil.move(f'{design}_post_synthesis.sdc', f'outputs/{design}.sdc')
        shutil.move(f'{design}_post_synthesis.sdf', f'outputs/{design}.{timing_corner}.sdf')
    else:
        # If timing analysis is on or we are not generating a post-implementation
        # netlist, just produce blank files. These will trigger any future nodes
        # that use them to skip.
        open(f'outputs/{design}.vg', 'a')
        open(f'outputs/{design}.sdc', 'a')
        open(f'outputs/{design}.{timing_corner}.sdf', 'a')
